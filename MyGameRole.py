#以下是对特定游戏对象的构建
#是对'https://github.com/greerviau/SnakeAI'的翻译和修改
from gameai_frame import GameRole as gr
import random
import game_globaldata as g
import pygame as pg
#snake, sample for parallel train(share the same game stage and don't interfere each other)
#snake's food is generated by Snake class ite self
class Snake(gr.GameRole):
    def __init__(self):
        super(Snake, self).__init__()
        self.score = 3#initialy a snake have a head and two body

        self.food = [0, 0]
        self._generate_food()
        #self.food_list = []#list contain food found, used for replay
        #head pos(in block)
        self.head = [(g.SCN_BLOCKNUM_X >> 1) + random.randint(-2, 2),\
                     (g.SCN_BLOCKNUM_Y >> 1) + random.randint(-2, 2)]
        self.body = [[self.head[0], self.head[1] + 1],\
                     [self.head[0], self.head[1] + 2]]

        self.mv_x = 0 #blocked val
        self.mv_y = 0 #blocked val

        self.__print_dead_msg = True
        return
    def _generate_food(self):
        self.food[0] = random.randint(2, g.SCN_BLOCKNUM_X - 2)
        self.food[1] = random.randint(2, g.SCN_BLOCKNUM_Y - 2)
        return
    #grdx : pos x in blocked size
    def _checkcollide_body(self, grdx, grdy):
        if [grdx, grdy] in self.body:
            return True
        return False
    def _checkcollide_food(self, grdx, grdy):
        if grdx == self.food[0] and grdy == self.food[1]:
            return True
        return False
    def _checkcollide_wall(self, grdx, grdy):
        if grdx < 1 or grdx > g.SCN_BLOCKNUM_X - 1 or\
           grdy < 1 or grdy > g.SCN_BLOCKNUM_Y - 1:
            return True
        if g.MAP[grdy][grdx] >= g.MAP_ENUM_WALL:
            return True
        return False
    def _shiftbody(self):
        body_len = len(self.body)
        for i in range(1, body_len):
            self.body[body_len - i][0] = self.body[body_len - i - 1][0]
            self.body[body_len - i][1] = self.body[body_len - i - 1][1]
        self.body[0][0] = self.head[0]
        self.body[0][1] = self.head[1]
        self.head[0] += self.mv_x
        self.head[1] += self.mv_y
        return
    def _move_up(self):
        if self.mv_y != 1:
            self.mv_x = 0
            self.mv_y = -1
            self.illus_movement = 'UP'
        return
    def _move_down(self):
        if self.mv_y != -1:
            self.mv_x = 0
            self.mv_y = 1
            self.illus_movement = 'DOWN'
        return
    def _move_left(self):
        if self.mv_x != 1:
            self.mv_x = -1
            self.mv_y = 0
            self.illus_movement = 'LEFT'
        return
    def _move_right(self):
        if self.mv_x != -1:
            self.mv_x = 1
            self.mv_y = 0
            self.illus_movement = 'RIGHT'
        return
    #call this before _shiftbody
    def _eat(self):
        self.timeleft = self.timelimit
        self.score += 1
        body_len = len(self.body)
        if body_len > 0:
            self.body.append([self.body[-1][0], self.body[-1][1]])
        else:
            self.body.append([self.head[0], self.head[1]])
        self._generate_food()
        while self.food == self.head:
            self._generate_food()
        return
    def calculate_fitness(self):
        if self.score < 10:
            self.fitness = (self.lifetime ** 2) * (2 ** self.score)
        else:
            self.fitness = (self.lifetime ** 2) * (2 ** 10) * (self.score - 9)
        return
    #assert len(input) == 3
    def __formVision(self, input : list, indx):
        self.vision[indx] = input[0]
        self.vision[indx + 1] = input[1]
        self.vision[indx + 2] = input[2]
        return
    def _look_in_direction(self, dir):
        what_the_snake_looked = [0.0] * 3#retval
        pos = [self.head[0], self.head[1]]
        distance = 0.0
        food_found = False
        body_found = False

        pos[0] += dir[0]
        pos[1] += dir[1]
        distance += 1.0

        while not self._checkcollide_wall(pos[0], pos[1]):
            if (not food_found) and self._checkcollide_food(pos[0], pos[1]):
                food_found = True
                what_the_snake_looked[0] = 1.0
            if (not body_found) and self._checkcollide_body(pos[0], pos[1]):
                body_found=True
                what_the_snake_looked[1] = 1.0
            pos[0] += dir[0]
            pos[1] += dir[1]
            distance += 1.0
        
        what_the_snake_looked[2]= 1.0 / distance
        return what_the_snake_looked
    #看向蛇头的八个方向, 获取神经网络的输入
    #当然，只要可以获得这个输入就可以了，没有必要一定知道游戏内部数据
    def look(self):
        self.__formVision(self._look_in_direction([-1, 0]), 0)
        self.__formVision(self._look_in_direction([-1, -1]), 3)
        self.__formVision(self._look_in_direction([0, -1]), 6)
        self.__formVision(self._look_in_direction([1, -1]), 9)
        self.__formVision(self._look_in_direction([1, 0]), 12)
        self.__formVision(self._look_in_direction([1, 1]), 15)
        self.__formVision(self._look_in_direction([0, 1]), 18)
        self.__formVision(self._look_in_direction([-1, 1]), 21)
        return
    #draw to screen
    def show(self):
        if self.dead:
            if self.__print_dead_msg:
                print("Snake<{}> is Dead. Reason<{}>".format(self, self.illus_dead_reason))
                self.__print_dead_msg = False
            return
        interval = g.BLOCK_SIZE / 16
        square_size = g.BLOCK_SIZE - interval
        pg.draw.rect(g.SCN_Surface, (255, 0, 0),\
           pg.Rect(self.food[0] * g.BLOCK_SIZE, self.food[1] * g.BLOCK_SIZE,\
                    square_size, square_size))
        pg.draw.rect(g.SCN_Surface, (0, 0, 255),\
           pg.Rect(self.head[0] * g.BLOCK_SIZE, self.head[1] * g.BLOCK_SIZE,\
                    square_size, square_size))
        for i in range(len(self.body)):
             pg.draw.rect(g.SCN_Surface, (0, 0, 0),\
                pg.Rect(self.body[i][0] * g.BLOCK_SIZE, self.body[i][1] * g.BLOCK_SIZE,\
                        square_size, square_size))
        return
    #由神经网络输出得出AI操作的输出
    def think(self):
        self.descision = self.brain.output(self.vision)
        #deal the descision, generate move-----
        #and update self.illus_movement if need
        max_indx = 0
        max = 0.0
        for i in range(len(self.descision)):
            if self.descision[i] > max:
                max = self.descision[i]
                max_indx = i
        if max_indx == 0:
            self._move_up()           
        elif max_indx == 1:
            self._move_down()
        elif max_indx == 2:
            self._move_left()
        elif max_indx == 3:
            self._move_right()
        #--------------------------------------
        return
    def user_update(self):
        if not self.dead:
            self.lifetime += 1
            self.timeleft -= 1
            if self._checkcollide_food(self.head[0],self.head[1]):
                self._eat()      
            self._shiftbody()   

            #以下情况都判定蛇死亡
            if self._checkcollide_wall(self.head[0],self.head[1]): 
                self.dead = True
                self.illus_dead_reason = "Collide Wall"
            elif self._checkcollide_body(self.head[0],self.head[1]): 
                self.dead = True
                self.illus_dead_reason = "Collide Body"
            elif self.timeleft < 1: 
                self.dead = True
                self.illus_dead_reason = "Time out"
        return
    #override----------------------------------------
    def clone(self):
        retval = Snake()
        retval.brain = self.brain.clone()
        return retval
    def crossover(self, partner):
        retval = Snake()
        retval.brain = self.brain.crossover(partner.brain)
        return retval
    #-----------------------------------------------
#sample for sequence trainning, since the game stage is not shareable
class Mario(gr.GameRole):
    pass